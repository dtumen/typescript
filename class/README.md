# Раздел 5: Class.

## Конструктор

> **Конструктор** - специальный метод, который вызывается в момент создания объекта с помощью оператора **`new`**.

- после этого, свойства присваиваются объекту(экземпляру класса).

Пример:
```ts
class User {
    name: string

    constructor(name: string) {
        this.name = name;
    }
}

const user = new User('Jonh'); 
// => John - то, что попадёт в конструктор и после этого будет присвоение свойства объекту.
```

Особенности конструктора:
- автоматически вызывается при использовании оператора `new`,
- всегда возвращает экземпляр класса(инстанс),
- нельзя вернуть другой тип данных.
- не поддерживает использование дженериков в качестве параметров.

- Чтобы использовать более вариативную логику классов, мы можем использовать **перегрузка конструктора**(`Overload`).

> **Реализация Overload** состоит из объявления нескольких **сигнатур конструктора** и одной реализации, которая удовлетворяет всем сигнатурам. 

Пример `Перегрузки конструктора (Overload)`:
```ts
class User {
    name: string
    age: number

    constructor();
    constructor(name: string);
    constructor(age: number);
    constructor(nameOrage?: string | number) {
        if (typeof nameOrage === 'string') {
            this.name = nameOrage;
        } else if (typeof nameOrage === 'number') {
            this.age = nameOrage;
        }
    }
}

const userName = new User('John'); // => { name: 'John' }
const userAge = new User(33); // => { age: 33 }
```

- `constructor(nameOrage?: string | number)` - **конструктор имплементации**, который должен по своей структуре удовлетворять вышестоящим конструкторам. 
- 3 первых конструктора - это конструкторы перезагрузки
> Говорить как: есть класс `User`, с 3-мя перезагрузками
- лучше не использовать такой подход!
>[!TIP]
>Перезагрузка полезна когда реализаций немного (2-3), но когда требуется много вариативных реализаций, то это становится нечитабельным, трудно поддерживаемым и непонятным.

## Метод
> **Метод** - это функция, которая выполняет операции над атрибутами экземпляра.

- находится внутри класса, под конструктором


## `Getter`, `Setter`
**геттеры и сеттеры** позволяют контролировать доступ к свойствам объекта.
- геттер получает значение свойства,
- сеттер устанавливает его

Зачем нужны геттеры и сеттеры?
- **Инкапсуляция**: позволяют скрыть детали реализации и внутреннее состояние объекта, предоставляя публичный интерфейс для работы.
- **Контроль над доступом**: можно добавить дополнительную логику при установке или получении значения свойства (например, проверку или изменение данных).

Особенности:
- **Наименование**: свойства для геттеров и сеттеров обычно начинают с `_`, **чтобы отличать их от обычных свойств**.
- **Типизация**: тип значения, которое принимает сеттер, автоматически определяется типом, возвращаемым геттером. Можно использовать объединение типов (union types) для гибкости.
- **Read-Only**: если у класса только геттер, свойство считается доступным только для чтения.
- **Асинхронность**: геттеры и сеттеры не могут быть асинхронными

## Implements или Реализация интерфейса.

**`implements`** или реализация - ключевое слово, которое используется для реализации классом того, что обозначено в `interface`.

- с помощью `implements`, мы обязываем класс реализовать интерфейс, который мы описали, в полной мере.
- один класс может реализовать сколько угодно интерфейсов через запятую.

Пример 1. Реализация нескольких интерфейсов в классе:
```ts
interface Animal{}
interface IOviparous{} // указывает на возможность откладывать яйца.

class Bird implements Animal, IOviparous {}
```

## Extends - наследование 

Ключевые аспекты наследования:

- `super` - делает референс к исходному классу от которого мы наследуемся!
  - вызывает конструктор и методы базового класса в дочернем.
- `override` - ключевое слово, которое указывает на то, что метод был переопределён
- возможность расширения существующих классов без дублирования кода,
- переопределение конструктора и методов в дочернем классе с возможностью добавления новой логики.

Порядок вызова конструктора и свойств:
1. Сначала инициализируются свойства **родительского класса**, вызывается его конструктор, 
2. Затем инициализируются свойства дочернего класса и вызывается его конструктор.

Пример:
```ts
class User {
  name: string = 'user';

  constructor() {
    console.log(this.name);
  }
}

class Admin extends User {
  name: string = 'admin'

  constructor() {
    super()
    console.log(this.name);
  }
}

const admin = new Admin(); // user, admin - то есть сначала конструктор родителя, потом дочерний.
```
- при наследовании классов, первой инструкцией в конструкторе дочернего класса должен быть вызов **`super`**
- нельзя обращаться к `this` до вызова `super`, это приведёт к ошибке.

Пример 2. Наследование от встроенного класса `Error`:
```ts
class HttpError extends Error {
    code: number;

    constructor(message: string, code?: number) {
        super(message);
        this.code = code ?? 500;
    }
}
```
- `??` - возвращает 500 если `code` === `undefined || null` - оператор нулевого слияния
- Возможность конструирования кастомных классов ошибок на базе стандартного класса ошибок, расширяя его дополнительной функциональностью.

### Отличия Имплементации и Наследования:
- наследование позволяет создать **зависимость** между классами, передавая свойства от одного класса к другому.
- имплементация же определяёт прообраз класса до его реализации,
- наследование может привести к **сильной связанности кода**, что усложняет его поддержку и модификацию.


## Композиция против наследования.

**Проблемы наследования:**

- Смешивание бизнес-логики с утилитарными классами.
- Наследование может привести к наследованию лишних методов или свойств.
- Трудности при переопределении стандартных методов для достижения необходимого поведения.

**Преимущества композиции:**

- Позволяет создавать классы, комбинируя различные объекты без жесткой связи между ними.
- Упрощает код, делая его более модульным и уменьшая связанность.
- Обеспечивает большую гибкость в управлении составляющими классов.