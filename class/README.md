# Раздел 5: Class.

## Конструктор

> **Конструктор** - специальный метод, который вызывается в момент создания объекта с помощью оператора **`new`**.

- после этого, свойства присваиваются объекту(экземпляру класса).

Пример:
```ts
class User {
    name: string

    constructor(name: string) {
        this.name = name;
    }
}

const user = new User('Jonh'); 
// => John - то, что попадёт в конструктор и после этого будет присвоение свойства объекту.
```

Особенности конструктора:
- автоматически вызывается при использовании оператора `new`,
- всегда возвращает экземпляр класса(инстанс),
- нельзя вернуть другой тип данных.
- не поддерживает использование дженериков в качестве параметров.

- Чтобы использовать более вариативную логику классов, мы можем использовать **перегрузка конструктора**(`Overload`).

> **Реализация Overload** состоит из объявления нескольких **сигнатур конструктора** и одной реализации, которая удовлетворяет всем сигнатурам. 

Пример `Перегрузки конструктора (Overload)`:
```ts
class User {
    name: string
    age: number

    constructor();
    constructor(name: string);
    constructor(age: number);
    constructor(nameOrage?: string | number) {
        if (typeof nameOrage === 'string') {
            this.name = nameOrage;
        } else if (typeof nameOrage === 'number') {
            this.age = nameOrage;
        }
    }
}

const userName = new User('John'); // => { name: 'John' }
const userAge = new User(33); // => { age: 33 }
```

- `constructor(nameOrage?: string | number)` - **конструктор имплементации**, который должен по своей структуре удовлетворять вышестоящим конструкторам. 
- 3 первых конструктора - это конструкторы перезагрузки
> Говорить как: есть класс `User`, с 3-мя перезагрузками
- лучше не использовать такой подход!
>[!TIP]
>Перезагрузка полезна когда реализаций немного (2-3), но когда требуется много вариативных реализаций, то это становится нечитабельным, трудно поддерживаемым и непонятным.

## Метод
> **Метод** - это функция, которая выполняет операции над атрибутами экземпляра.

- находится внутри класса, под конструктором


## `Getter`, `Setter`
**геттеры и сеттеры** позволяют контролировать доступ к свойствам объекта.
- геттер получает значение свойства,
- сеттер устанавливает его

Зачем нужны геттеры и сеттеры?
- **Инкапсуляция**: позволяют скрыть детали реализации и внутреннее состояние объекта, предоставляя публичный интерфейс для работы.
- **Контроль над доступом**: можно добавить дополнительную логику при установке или получении значения свойства (например, проверку или изменение данных).

Особенности:
- **Наименование**: свойства для геттеров и сеттеров обычно начинают с `_`, **чтобы отличать их от обычных свойств**.
- **Типизация**: тип значения, которое принимает сеттер, автоматически определяется типом, возвращаемым геттером. Можно использовать объединение типов (union types) для гибкости.
- **Read-Only**: если у класса только геттер, свойство считается доступным только для чтения.
- **Асинхронность**: геттеры и сеттеры не могут быть асинхронными

## Implements или Реализация интерфейса.

**`implements`** или реализация - ключевое слово, которое используется для реализации классом того, что обозначено в `interface`.

- с помощью `implements`, мы обязываем класс реализовать интерфейс, который мы описали, в полной мере.
- один класс может реализовать сколько угодно интерфейсов через запятую.

Пример 1. Реализация нескольких интерфейсов в классе:
```ts
interface Animal{}
interface IOviparous{} // указывает на возможность откладывать яйца.

class Bird implements Animal, IOviparous {}
```